<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>制作自己的引擎 | Ayin</title><meta name="author" content="翼轸"><meta name="copyright" content="翼轸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="干个小引擎先试试水">
<meta property="og:type" content="article">
<meta property="og:title" content="制作自己的引擎">
<meta property="og:url" content="https://ayinzhang.github.io/2026/02/18/2026-2-18-Build%20your%20own%20engine/index.html">
<meta property="og:site_name" content="Ayin">
<meta property="og:description" content="干个小引擎先试试水">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picx.zhimg.com/v2-cd705e99c30a580cfc272964bedbb66c_1440w.png?source=ccfced1a">
<meta property="article:published_time" content="2026-02-17T16:00:00.000Z">
<meta property="article:modified_time" content="2026-02-27T03:36:11.290Z">
<meta property="article:author" content="翼轸">
<meta property="article:tag" content="引擎工具">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picx.zhimg.com/v2-cd705e99c30a580cfc272964bedbb66c_1440w.png?source=ccfced1a"><link rel="shortcut icon" href="https://fastly.jsdelivr.net/gh/ayinzhang/ayinzhang.github.io/img/icon.png"><link rel="canonical" href="https://ayinzhang.github.io/2026/02/18/2026-2-18-Build%20your%20own%20engine/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f74029fa7cc77ea7995800ef7950497d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"EN","msgToSimplifiedChinese":"ZH"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '制作自己的引擎',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-27 11:36:11'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/en/"><i class="fa-fw fas fa-e"></i><span> 语言</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picx.zhimg.com/v2-cd705e99c30a580cfc272964bedbb66c_1440w.png?source=ccfced1a')"><nav id="nav"><span id="blog-info"><a href="/" title="Ayin"><span class="site-name">Ayin</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/en/"><i class="fa-fw fas fa-e"></i><span> 语言</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">制作自己的引擎</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-17T16:00:00.000Z" title="发表于 2026-02-18 00:00:00">2026-02-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-27T03:36:11.290Z" title="更新于 2026-02-27 11:36:11">2026-02-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%BC%95%E6%93%8E%E7%9B%B8%E5%85%B3/">引擎相关</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="制作自己的引擎"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>可能是想试下目前能力极限，证明下自己还是没忘引擎的本，顺便备战春招；也可能是受动物井，Games104等的启发；还有可能是最近拆了Godot以及Jolt的设计感觉好像也没那么难。总之就是开始写自己小引擎，值此新年之际算是有了阶段性成果，故而才有了这个系列。</p>
<p>来的应该基本都是内行，这里也就简单介绍下功能：物体树状组织，组件赋予功能，场景序列存取。渲染采用OpenGL+GPU Instance，模拟采用线程池+工作窃取。然后重点再介绍下名称和图标，名称与宝可梦的多变怪同名，因为开始就想的以物理模拟为主，毕竟个人很注重游戏中的交互体验，反馈到技术栈上就是图形学的模拟动画。图标形象则主要取自洛克王国的多灵，大概是个人页游退坑前夕出的宠物，很喜欢其背景设定的“传说中灵魂的收集者，通过吸收其他宠物的灵魂，来塑造自己的身躯”，个人在写引擎功能架构时也多有借鉴成熟引擎的操作。</p>
<p><img src="https://picx.zhimg.com/80/v2-d3f714e39f3e160c60dc3e7d8507d481_1440w.gif?source=ccfced1a" alt="img"></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先，在写之前应该对引擎架构及自己的能力有一定基本认知。按照Games104 ，引擎应该包含 5 层架构：</p>
<ul>
<li>功能层：提供引擎表面的基础服务。渲染、Game Tick、数值等。</li>
<li>工具层：提供开发人员的可交互编辑内容。</li>
<li>核心层：提供底层支持。例如内存管理及 3D 引擎常用的向量计算。</li>
<li>资源层：管理创作资产。</li>
<li>平台层：提供跨平台支持。</li>
</ul>
<p>其中平台层一看就不是我等小引擎能涉及的存在，资源层的话处理各种图片视频音频模型想想都很费事，调库的话可能能帮下，姑且按下不表。其他三层再砍的话引擎就可以不用跑了，目前项目代码也按此架构。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Ditto/</span></span><br><span class="line"><span class="string">├──</span> <span class="string">Engine/</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">Core/</span>                <span class="comment"># 核心层</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">Graphics/</span>            <span class="comment"># 图形/渲染系统（功能层）</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">Physics/</span>             <span class="comment"># 物理系统（功能层）</span></span><br><span class="line"><span class="string">│</span>   <span class="string">└──</span> <span class="string">Resources/</span>           <span class="comment"># 资源层</span></span><br><span class="line"><span class="string">├──</span> <span class="string">Editor/</span>                  <span class="comment"># 工具层</span></span><br><span class="line"><span class="string">├──</span> <span class="string">Assets/</span>                  <span class="comment"># 项目资产</span></span><br><span class="line"><span class="string">├──</span> <span class="string">3rdParty/</span>                <span class="comment"># 第三方库</span></span><br><span class="line"><span class="string">└──</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>有了基本架构后，第一步该做当然是处理渲染。没办法，无论你做了什么，只有渲染出来才会被看见。相较于场景，个人先做的UI界面，毕竟UI在场景的上层先被看到，且有了Editor界面后整体看上去才更像个引擎。</p>
<h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><p>这各种文字，按钮，输入框，自己搓过于费时费力，且美观度有待商榷。所以我走的<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui">IMGUI</a>，底层有OpenGL，DirectX，Vulkan等多种可选，所有的控件都手动指定实现，当然性能也是极佳的。也有一个专门的网站<a target="_blank" rel="noopener" href="https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html">演示</a>其能达到的效果。大致用法如下，和Unity Editor写法有些许相似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;设置面板&quot;</span>, <span class="literal">nullptr</span>, ImGuiWindowFlags_AlwaysAutoResize);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> showExtra = <span class="literal">false</span>;</span><br><span class="line">ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;显示高级选项&quot;</span>, &amp;showExtra);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> brightness = <span class="number">0.8f</span>;</span><br><span class="line">ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;亮度&quot;</span>, &amp;brightness, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="string">&quot;%.2f&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> quality = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* levels[] = &#123; <span class="string">&quot;低&quot;</span>, <span class="string">&quot;中&quot;</span>, <span class="string">&quot;高&quot;</span> &#125;;</span><br><span class="line">ImGui::<span class="built_in">Combo</span>(<span class="string">&quot;质量&quot;</span>, &amp;quality, levels, <span class="built_in">IM_ARRAYSIZE</span>(levels));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (showExtra) &#123;</span><br><span class="line">    ImGui::<span class="built_in">Separator</span>();</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> color[<span class="number">3</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;背景色&quot;</span>, color);</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;重置&quot;</span>)) &#123;</span><br><span class="line">        color[<span class="number">0</span>] = color[<span class="number">1</span>] = color[<span class="number">2</span>] = <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;点击恢复默认&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br></pre></td></tr></table></figure>

<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>一般来说，引擎都会有Tool，Scene，Game，Hierarchy，File，Inspector等界面。个人不想做资源层Ban掉File，不想做做多视图故合并Scene和Game。大概这里就只用做Tool工具栏，Hierarchy层级，Scene视图，Inspector属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Editor::Draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">    ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DrawToolbar</span>();</span><br><span class="line">    <span class="keyword">if</span> (showHierarchy) <span class="built_in">DrawHierarchy</span>();</span><br><span class="line">    <span class="keyword">if</span> (showScene) <span class="built_in">DrawScene</span>();</span><br><span class="line">    <span class="keyword">if</span> (showInspector) <span class="built_in">DrawInspector</span>();</span><br><span class="line">    <span class="built_in">DrawPopups</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绘制工具栏"><a href="#绘制工具栏" class="headerlink" title="绘制工具栏"></a>绘制工具栏</h4><p>先从顶部工具栏开始，由于不考虑各种扩展插件，所以工具栏只有保存&#x2F;加载场景，显示&#x2F;隐藏界面的作用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Editor::DrawToolbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginMainMenuBar</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">BeginMenu</span>(<span class="string">&quot;File&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Save Scene&quot;</span>, <span class="string">&quot;Ctrl+S&quot;</span>)) showSavePopup = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Load Scene&quot;</span>, <span class="string">&quot;Ctrl+L&quot;</span>)) showLoadPopup = <span class="literal">true</span>;</span><br><span class="line">            ImGui::<span class="built_in">EndMenu</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">BeginMenu</span>(<span class="string">&quot;View&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Toggle Hierarchy&quot;</span>, <span class="literal">NULL</span>, showHierarchy)) showHierarchy = !showHierarchy;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Toggle Scene&quot;</span>, <span class="literal">NULL</span>, showScene)) showScene = !showScene;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Toggle Inspector&quot;</span>, <span class="literal">NULL</span>, showInspector)) showInspector = !showInspector;</span><br><span class="line">            ImGui::<span class="built_in">EndMenu</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">SameLine</span>(ImGui::<span class="built_in">GetWindowWidth</span>() * <span class="number">0.4f</span>);</span><br><span class="line">        <span class="keyword">if</span> (engine-&gt;state == Engine::State::Edit)</span><br><span class="line">        &#123;</span><br><span class="line">            ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_Button, <span class="built_in">ImVec4</span>(<span class="number">0.2f</span>, <span class="number">0.7f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>));</span><br><span class="line">            ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonHovered, <span class="built_in">ImVec4</span>(<span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>));</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Play&quot;</span>)) engine-&gt;<span class="built_in">SetEngineState</span>(Engine::State::Play);</span><br><span class="line">            ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_Button, <span class="built_in">ImVec4</span>(<span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>));</span><br><span class="line">            ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonHovered, <span class="built_in">ImVec4</span>(<span class="number">0.9f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>));</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Stop&quot;</span>)) engine-&gt;<span class="built_in">SetEngineState</span>(Engine::State::Edit);</span><br><span class="line">            ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">        <span class="keyword">if</span> (engine-&gt;state != Engine::State::Stop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Pause&quot;</span>)) engine-&gt;<span class="built_in">SetEngineState</span>(Engine::State::Stop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Conti&quot;</span>))</span><br><span class="line">            engine-&gt;<span class="built_in">SetEngineState</span>(Engine::State::Play);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> windowWidth = ImGui::<span class="built_in">GetWindowWidth</span>(), infoWidth = <span class="number">300.0f</span>;</span><br><span class="line">        ImGui::<span class="built_in">SameLine</span>(windowWidth - infoWidth);</span><br><span class="line">        ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Scene:&quot;</span>); ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">PushItemWidth</span>(<span class="number">150.0f</span>);</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">InputText</span>(<span class="string">&quot;##SceneName&quot;</span>, sceneNameBuffer, <span class="built_in">sizeof</span>(sceneNameBuffer), ImGuiInputTextFlags_EnterReturnsTrue))</span><br><span class="line">            <span class="keyword">if</span> (engine &amp;&amp; engine-&gt;scene) engine-&gt;scene-&gt;name = sceneNameBuffer;</span><br><span class="line">        ImGui::<span class="built_in">PopItemWidth</span>();</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">EndMainMenuBar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绘制功能界面"><a href="#绘制功能界面" class="headerlink" title="绘制功能界面"></a>绘制功能界面</h4><p>工具栏整完了，接着就是Hierarchy层级，Scene视图，Inspector属性三个功能界面。</p>
<p>首先是Hierarchy层级，由于个人采用的树状层级所以这里的逻辑显得更复杂。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Editor::DrawHierarchy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> menuBarHeight = ImGui::<span class="built_in">GetFrameHeight</span>();</span><br><span class="line">    <span class="type">float</span> windowWidth = ImGui::<span class="built_in">GetIO</span>().DisplaySize.x;</span><br><span class="line">    <span class="type">float</span> windowHeight = ImGui::<span class="built_in">GetIO</span>().DisplaySize.y - menuBarHeight;</span><br><span class="line">    <span class="type">float</span> hierarchyWidth = <span class="number">0.125f</span> * windowWidth; <span class="comment">//占1/8宽</span></span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">SetNextWindowPos</span>(<span class="built_in">ImVec2</span>(<span class="number">0</span>, menuBarHeight));</span><br><span class="line">    ImGui::<span class="built_in">SetNextWindowSize</span>(<span class="built_in">ImVec2</span>(hierarchyWidth, windowHeight));</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Hierarchy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginPopupContextWindow</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Create Cube&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject* cube = <span class="keyword">new</span> <span class="built_in">GameObject</span>(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">            cube-&gt;<span class="built_in">AddComponent</span>&lt;RendererComponent&gt;(RendererComponent::Type::Cube);</span><br><span class="line">            engine-&gt;scene-&gt;gameObjects.<span class="built_in">push_back</span>(cube);</span><br><span class="line">            selectedObject = cube;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Create Sphere&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject* sphere = <span class="keyword">new</span> <span class="built_in">GameObject</span>(<span class="string">&quot;Sphere&quot;</span>);</span><br><span class="line">            sphere-&gt;<span class="built_in">AddComponent</span>&lt;RendererComponent&gt;(RendererComponent::Type::Sphere);</span><br><span class="line">            engine-&gt;scene-&gt;gameObjects.<span class="built_in">push_back</span>(sphere);</span><br><span class="line">            selectedObject = sphere;</span><br><span class="line">        &#125;</span><br><span class="line">        ImGui::<span class="built_in">EndPopup</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginDragDropTarget</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> ImGuiPayload* payload = ImGui::<span class="built_in">AcceptDragDropPayload</span>(<span class="string">&quot;GAMEOBJECT&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject* droppedObj = *(GameObject**)payload-&gt;Data;</span><br><span class="line">            <span class="keyword">if</span> (droppedObj)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (droppedObj-&gt;parent) droppedObj-&gt;<span class="built_in">RemoveFromParent</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span>&amp; rootList = engine-&gt;scene-&gt;gameObjects;</span><br><span class="line">                    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(rootList.<span class="built_in">begin</span>(), rootList.<span class="built_in">end</span>(), droppedObj);</span><br><span class="line">                    <span class="keyword">if</span> (it != rootList.<span class="built_in">end</span>()) rootList.<span class="built_in">erase</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">                engine-&gt;scene-&gt;gameObjects.<span class="built_in">push_back</span>(droppedObj);</span><br><span class="line">                droppedObj-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ImGui::<span class="built_in">EndDragDropTarget</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (GameObject* obj : engine-&gt;scene-&gt;gameObjects) <span class="built_in">DrawGameObjectNode</span>(obj);</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是Scene视图，没有什么特别逻辑，只是记录了下FPS以及PPF(物理耗时)，毕竟引擎以物理为主，且涉及到多线程，需要精细对比。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Editor::DrawScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> menuBarHeight = ImGui::<span class="built_in">GetFrameHeight</span>();</span><br><span class="line">    <span class="type">float</span> windowWidth = ImGui::<span class="built_in">GetIO</span>().DisplaySize.x;</span><br><span class="line">    <span class="type">float</span> windowHeight = ImGui::<span class="built_in">GetIO</span>().DisplaySize.y - menuBarHeight;</span><br><span class="line">    <span class="type">float</span> hierarchyWidth = <span class="number">0.125f</span> * windowWidth;</span><br><span class="line">    <span class="type">float</span> sceneWidth = <span class="number">0.625f</span> * windowWidth; <span class="comment">//占1/2宽</span></span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">SetNextWindowPos</span>(<span class="built_in">ImVec2</span>(hierarchyWidth, menuBarHeight));</span><br><span class="line">    ImGui::<span class="built_in">SetNextWindowSize</span>(<span class="built_in">ImVec2</span>(sceneWidth, windowHeight));</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Scene&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Scene View&quot;</span>);</span><br><span class="line"></span><br><span class="line">    frame++; deltaTime += engine-&gt;deltaTime;</span><br><span class="line">    <span class="keyword">if</span> (deltaTime &gt; <span class="number">1.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fps = frame / deltaTime;</span><br><span class="line">        ppf = <span class="number">1e6</span>f * engine-&gt;physicsTime / engine-&gt;physicsCnt;</span><br><span class="line">        frame = <span class="number">0</span>; deltaTime = <span class="number">0</span>; engine-&gt;physicsCnt = <span class="number">0</span>; engine-&gt;physicsTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (deltaTime &lt; <span class="number">0</span>) deltaTime = <span class="number">0</span>;</span><br><span class="line">    ImVec2 windowPos = ImGui::<span class="built_in">GetWindowPos</span>();</span><br><span class="line">    ImVec2 windowSize = ImGui::<span class="built_in">GetWindowSize</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">GetForegroundDrawList</span>()-&gt;<span class="built_in">AddText</span>(</span><br><span class="line">        <span class="built_in">ImVec2</span>(windowPos.x + windowSize.x - <span class="number">80</span>, windowPos.y + <span class="number">20</span>),</span><br><span class="line">        <span class="built_in">IM_COL32</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), (<span class="string">&quot;FPS: &quot;</span> + std::<span class="built_in">to_string</span>((<span class="type">int</span>)fps)).<span class="built_in">c_str</span>()</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (engine-&gt;state == Engine::State::Play)</span><br><span class="line">        ImGui::<span class="built_in">GetForegroundDrawList</span>()-&gt;<span class="built_in">AddText</span>(</span><br><span class="line">            <span class="built_in">ImVec2</span>(windowPos.x + windowSize.x - <span class="number">80</span>, windowPos.y + <span class="number">40</span>),</span><br><span class="line">            <span class="built_in">IM_COL32</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), (<span class="string">&quot;PPF: &quot;</span> + std::<span class="built_in">to_string</span>((<span class="type">int</span>)ppf)).<span class="built_in">c_str</span>()</span><br><span class="line">        );</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是Inspector属性，具体的组件交由物体绘制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Editor::DrawInspector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> menuBarHeight = ImGui::<span class="built_in">GetFrameHeight</span>();</span><br><span class="line">    <span class="type">float</span> windowWidth = ImGui::<span class="built_in">GetIO</span>().DisplaySize.x;</span><br><span class="line">    <span class="type">float</span> windowHeight = ImGui::<span class="built_in">GetIO</span>().DisplaySize.y - menuBarHeight;</span><br><span class="line">    <span class="type">float</span> hierarchyWidth = <span class="number">0.125f</span> * windowWidth;</span><br><span class="line">    <span class="type">float</span> sceneWidth = <span class="number">0.625f</span> * windowWidth;</span><br><span class="line">    <span class="type">float</span> inspectorWidth = <span class="number">0.25f</span> * windowWidth;</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">SetNextWindowPos</span>(<span class="built_in">ImVec2</span>(hierarchyWidth + sceneWidth, menuBarHeight));</span><br><span class="line">    ImGui::<span class="built_in">SetNextWindowSize</span>(<span class="built_in">ImVec2</span>(inspectorWidth, windowHeight));</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Inspector&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!selectedObject) &#123; ImGui::<span class="built_in">End</span>(); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (engine-&gt;state == Engine::State::Play) ImGui::<span class="built_in">BeginDisabled</span>();</span><br><span class="line">    selectedObject-&gt;<span class="built_in">OnInspectorGUI</span>();</span><br><span class="line">    <span class="keyword">if</span> (engine-&gt;state == Engine::State::Play) ImGui::<span class="built_in">EndDisabled</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>之后，各种界面的雏形就出来了。这里可以用IMGUI的Main支，也可以用Docker支，使用Docker的话还能再整下窗口停泊等。但个人懒逼，所以目前就这样吧。</p>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>前文说过要处理Play时的表现，那就直接开始吧。目前只有刚体，毕竟软体会打乱mesh结构，这让之前写的GPU Instance吃什么（GPU Instance：是啊，吃什么）。所以目前物理的主要工作还是碰撞处理，宽向使用AABB，窄向的话对这种几何体应该SAT检测更好些，但为了扩展性还是走GJK-EPA。</p>
<h3 id="准备-2"><a href="#准备-2" class="headerlink" title="准备"></a>准备</h3><p>这里还是简要介绍下前面提及的各碰撞检测算法，为了方便以下都以二维凸边形情况举例，且仅涉及算法思想。</p>
<h4 id="分离轴算法（SAT）"><a href="#分离轴算法（SAT）" class="headerlink" title="分离轴算法（SAT）"></a>分离轴算法（SAT）</h4><p>算法思想很简单，找到一条轴能分开两物体，找不到就没碰撞。这样的话以物体的边作轴最快，三维情况下复杂度为边数和 O(n+m) 。</p>
<p><img src="https://pica.zhimg.com/80/v2-dfd12738504619cae2e0024055e0275d_1440w.png?source=ccfced1a" alt="img"></p>
<h4 id="GJK-EPA"><a href="#GJK-EPA" class="headerlink" title="GJK-EPA"></a>GJK-EPA</h4><p>GJK涉及到单纯形和闵可夫斯基差，对蓝色区域和绿色区域的碰撞检测，可以得到橙色区域，因橙色区域包含原点故发生碰撞。其中橙色区域的形状来自两区域的形状（想象蓝色区域为一个空架子，绿色区域为约束—将蓝色区域的某顶点限制在绿色区域的边上，绕绿色区域的边平移蓝色区域即可得到红色区域的形状），位置来自两物体的相对位置（CD间差(1，1)，故J点(1, 1)）。三维情况下的复杂度近乎常数，极端条件下才能到 O(n+m) 。</p>
<p>而EPA与GJK类似，但不是找原点，而是离原点最近的边以确定穿插深度。三维情况下的复杂度为 O(k(n+m+f)) 。</p>
<p><img src="https://picx.zhimg.com/80/v2-bd02644cd94fd46b2aecff409aac6ced_1440w.png?source=ccfced1a" alt="img"></p>
<h3 id="物理步进"><a href="#物理步进" class="headerlink" title="物理步进"></a>物理步进</h3><h4 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h4><p>主流程大致如下，因为刚体所以走的冲量方案，仅以位置修正为辅助防止持续穿透。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Physics::UpdatePhysics</span><span class="params">(<span class="type">float</span> dt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t += dt; <span class="keyword">if</span> (t &lt; deltaTime) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> steps = glm::<span class="built_in">min</span>(<span class="number">3.0f</span>, t / deltaTime); t = <span class="built_in">fmod</span>(t, deltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">0</span>; step &lt; steps; ++step)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 清除上一帧的碰撞数据</span></span><br><span class="line">        collisionData.<span class="built_in">clear</span>(); colliderPairs.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 2. 积分力（更新速度和角速度）</span></span><br><span class="line">        <span class="built_in">IntegrateForce</span>(deltaTime);</span><br><span class="line">        <span class="comment">// 3. 更新BVH树</span></span><br><span class="line">        <span class="keyword">if</span> (bvhTree) bvhTree-&gt;<span class="built_in">UpdateBVHTree</span>();</span><br><span class="line">        <span class="comment">// 4. 宽相位碰撞检测</span></span><br><span class="line">        <span class="built_in">HandleBroadCollisions</span>();</span><br><span class="line">        <span class="comment">// 5. 窄相位碰撞检测</span></span><br><span class="line">        <span class="built_in">HandleNarrowCollisions</span>();</span><br><span class="line">        <span class="comment">// 6. 多轮顺序冲量求解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> iter = <span class="number">0</span>; iter &lt; iterations; ++iter) <span class="built_in">SolveCollisions</span>(iter);</span><br><span class="line">        <span class="comment">// 7. 应用位置修正</span></span><br><span class="line">        <span class="built_in">ApplyPositionCorrections</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目前物理按60FPS走，渲染没有。所以每次物理更新后要更新下模型矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> collider : colliders) collider-&gt;transform-&gt;<span class="built_in">UpdateTransform</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新bvh树"><a href="#更新bvh树" class="headerlink" title="更新bvh树"></a>更新bvh树</h4><p>这里简单贴下BVH树的更新流程。为了宽向AABB检测，我构造了基于SAH的AABB BVH树，每个物理帧更新并抽样重构以维持较优结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BVHTree::UpdateBVHTree</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">UpdateAllAABBs</span>(root);</span><br><span class="line">    <span class="built_in">SampleAndRebuild</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BVHTree::UpdateAllAABBs</span><span class="params">(BVHNode* node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;isLeaf) </span><br><span class="line">    &#123;</span><br><span class="line">        Collider* collider = node-&gt;data.leaf.collider;</span><br><span class="line">        <span class="keyword">if</span> (collider &amp;&amp; collider-&gt;isDirty) &#123; collider-&gt;<span class="built_in">UpdateWorldAABB</span>(); node-&gt;aabb = collider-&gt;aabb; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UpdateAllAABBs</span>(node-&gt;data.child.left);</span><br><span class="line">        <span class="built_in">UpdateAllAABBs</span>(node-&gt;data.child.right);</span><br><span class="line">        node-&gt;<span class="built_in">UpdateAABB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BVHTree::SampleAndRebuild</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leafNodes.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    BVHNode* nodeToReinsert = leafNodes[currentSampleIndex];</span><br><span class="line">    <span class="built_in">ReinsertNode</span>(nodeToReinsert);</span><br><span class="line">    currentSampleIndex = (currentSampleIndex + <span class="number">1</span>) % leafNodes.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="宽向检测"><a href="#宽向检测" class="headerlink" title="宽向检测"></a>宽向检测</h4><p>既然有了BVH树，每次拿到一个AABB包围盒都可以直接靠树查询。但为了避免重复写入碰撞对，这里用了个标志位，只计入其和其前序的包围盒。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Physics::HandleBroadCollisions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Collider* collider : colliders)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (collider-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic)</span><br><span class="line">        &#123;</span><br><span class="line">            std::vector&lt;Collider*&gt; potentialCollisions;</span><br><span class="line">            <span class="keyword">if</span> (bvhTree) potentialCollisions = bvhTree-&gt;<span class="built_in">Query</span>(collider-&gt;aabb);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Collider* other : potentialCollisions)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (other == collider) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> alreadyExists = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : colliderPairs)</span><br><span class="line">                    <span class="keyword">if</span> ((pair.first == collider &amp;&amp; pair.second == other) || (pair.first == other &amp;&amp; pair.second == collider))</span><br><span class="line">                    &#123;</span><br><span class="line">                        alreadyExists = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!alreadyExists)</span><br><span class="line">                    <span class="keyword">if</span> (other-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic || other-&gt;rigidbody-&gt;type == RigidbodyComponent::Static)</span><br><span class="line">                        colliderPairs.<span class="built_in">push_back</span>(&#123; collider, other &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="窄向检测"><a href="#窄向检测" class="headerlink" title="窄向检测"></a>窄向检测</h4><p>窄向的话用的就是之前提及的GJK-EPA，但相对于二维，三维情况下明显复杂了许多。如在构造单纯形时就要分别处理不同维度情况：</p>
<ul>
<li>2点（线段）：判断原点相对于线段的位置，更新方向或退化为单点。</li>
<li>3点（三角形）：判断原点相对于三角形各边的位置，更新单纯形和方向。</li>
<li>4点（四面体）：检查原点是否在四面体内（即与每个面的法线方向关系），如果原点在四面体内，返回真；否则抛弃最远的面，更新方向。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Physics::HandleNarrowCollisions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : colliderPairs)</span><br><span class="line">    &#123;</span><br><span class="line">        Collider* colliderA = pair.first, * colliderB = pair.second;</span><br><span class="line">        CollisionInfo collisionInfo = <span class="built_in">GJK_CheckCollision</span>(colliderA, colliderB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (collisionInfo.flag &amp;&amp; collisionInfo.depth &gt; <span class="number">1e-3</span>)</span><br><span class="line">            collisionData.<span class="built_in">push_back</span>(<span class="built_in">CollisionData</span>(colliderA, colliderB, collisionInfo));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CollisionInfo <span class="title">GJK_CheckCollision</span><span class="params">(Collider* colliderA, Collider* colliderB)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CollisionInfo result;</span><br><span class="line">    glm::vec3 direction = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 初始方向</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;SupportPoint&gt; simplex;</span><br><span class="line">    simplex.<span class="built_in">push_back</span>(<span class="built_in">GetMinkowskiSupport</span>(colliderA, colliderB, direction));</span><br><span class="line">    direction = -simplex[<span class="number">0</span>].point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)  <span class="comment">// 限制次数防止卡死</span></span><br><span class="line">    &#123;</span><br><span class="line">        SupportPoint next = <span class="built_in">GetMinkowskiSupport</span>(colliderA, colliderB, direction);</span><br><span class="line">        <span class="keyword">if</span> (glm::<span class="built_in">dot</span>(next.point, direction) &lt; <span class="number">0</span>) <span class="keyword">return</span> result; <span class="comment">// 没过原点，无碰撞</span></span><br><span class="line"></span><br><span class="line">        simplex.<span class="built_in">push_back</span>(next);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UpdateSimplex</span>(simplex, direction))  <span class="built_in">EPA</span>(simplex, colliderA, colliderB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冲量求解"><a href="#冲量求解" class="headerlink" title="冲量求解"></a>冲量求解</h4><p>在获取了碰撞信息（碰撞点和深度）后，就需要用冲量推回了，这里还是稍微详细的列下步骤：</p>
<ul>
<li><strong>顺序求解与迭代</strong>：每帧将碰撞按穿透深度降序处理，并通过多次迭代（如4次）逐步收敛，减少误差累积。</li>
<li><strong>法向冲量</strong>：基于相对速度、恢复系数和穿透深度计算法向冲量，用于分离物体并补偿穿透。</li>
<li><strong>切向摩擦</strong>：根据相对切向速度分别计算静摩擦和动摩擦，将切向冲量限制在摩擦锥内，模拟表面阻力。</li>
<li><strong>刚体运动更新</strong>：冲量同时改变线速度和角速度，通过世界空间惯性张量转换实现真实旋转响应。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Physics::SolveCollisions</span><span class="params">(<span class="type">int</span> iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; data : collisionData) data.processed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">     std::<span class="built_in">sort</span>(collisionData.<span class="built_in">begin</span>(), collisionData.<span class="built_in">end</span>(), </span><br><span class="line">         [](<span class="type">const</span> CollisionData&amp; a, <span class="type">const</span> CollisionData&amp; b) &#123; <span class="keyword">return</span> a.info.depth &gt; b.info.depth; &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; data : collisionData)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (data.processed) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">ApplyImpulse</span>(data.colliderA, data.colliderB, data.info.normal, data.info.contactPointA, data.info.contactPointB, data.info.depth, iter);</span><br><span class="line"></span><br><span class="line">         data.processed = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Physics::ApplyImpulse</span><span class="params">(Collider* a, Collider* b, <span class="type">const</span> glm::vec3&amp; normal,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; contactPointA, <span class="type">const</span> glm::vec3&amp; contactPointB,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> penetrationDepth, <span class="type">int</span> iteration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> invMassA = (a-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic) ? <span class="number">1.0f</span> / a-&gt;rigidbody-&gt;mass : <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> invMassB = (b-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic) ? <span class="number">1.0f</span> / b-&gt;rigidbody-&gt;mass : <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    glm::mat3 invInertiaA = <span class="built_in">CalculateWorldInverseInertia</span>(a), invInertiaB = <span class="built_in">CalculateWorldInverseInertia</span>(b);</span><br><span class="line">    glm::vec3 rA = contactPointA - a-&gt;transform-&gt;position, rB = contactPointB - b-&gt;transform-&gt;position;</span><br><span class="line"></span><br><span class="line">    glm::vec3 velA = a-&gt;rigidbody-&gt;velocity + glm::<span class="built_in">cross</span>(a-&gt;rigidbody-&gt;angularVelocity, rA);</span><br><span class="line">    glm::vec3 velB = b-&gt;rigidbody-&gt;velocity + glm::<span class="built_in">cross</span>(b-&gt;rigidbody-&gt;angularVelocity, rB);</span><br><span class="line">    glm::vec3 relativeVel = velB - velA;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> normalVel = glm::<span class="built_in">dot</span>(relativeVel, normal);</span><br><span class="line">    <span class="keyword">if</span> (normalVel &gt; <span class="number">0.2f</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    glm::vec3 crossA = glm::<span class="built_in">cross</span>(rA, normal);</span><br><span class="line">    glm::vec3 crossB = glm::<span class="built_in">cross</span>(rB, normal);</span><br><span class="line"></span><br><span class="line">    glm::vec3 invInertiaCrossA = invInertiaA * crossA;</span><br><span class="line">    glm::vec3 invInertiaCrossB = invInertiaB * crossB;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> termA = invMassA + glm::<span class="built_in">dot</span>(crossA, invInertiaCrossA);</span><br><span class="line">    <span class="type">float</span> termB = invMassB + glm::<span class="built_in">dot</span>(crossB, invInertiaCrossB);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> denominator = termA + termB;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0.0f</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> biasFactor = <span class="number">0.3f</span> * (<span class="number">1.0f</span> - <span class="built_in">float</span>(iteration) / iterations);</span><br><span class="line">    <span class="type">float</span> bias = biasFactor * penetrationDepth / deltaTime;</span><br><span class="line">    <span class="type">float</span> j = -(<span class="number">1.0f</span> + restitution) * normalVel + bias;</span><br><span class="line">    j = glm::<span class="built_in">max</span>(<span class="number">0.0f</span>, j / denominator);</span><br><span class="line"></span><br><span class="line">    glm::vec3 impulse = j * normal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic)</span><br><span class="line">    &#123;</span><br><span class="line">        a-&gt;rigidbody-&gt;velocity -= impulse * invMassA;</span><br><span class="line">        a-&gt;rigidbody-&gt;angularVelocity += invInertiaA * glm::<span class="built_in">cross</span>(rA, impulse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic)</span><br><span class="line">    &#123;</span><br><span class="line">        b-&gt;rigidbody-&gt;velocity += impulse * invMassB;</span><br><span class="line">        b-&gt;rigidbody-&gt;angularVelocity += invInertiaB * glm::<span class="built_in">cross</span>(rB, -impulse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 tangent = relativeVel - normal * normalVel;</span><br><span class="line">    <span class="type">float</span> tangentLen = glm::<span class="built_in">length</span>(tangent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tangentLen &gt; <span class="number">1e-3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tangent = glm::<span class="built_in">normalize</span>(tangent);</span><br><span class="line">        <span class="type">float</span> tangentVel = glm::<span class="built_in">dot</span>(relativeVel, tangent);</span><br><span class="line"></span><br><span class="line">        glm::vec3 crossAT = glm::<span class="built_in">cross</span>(rA, tangent);</span><br><span class="line">        glm::vec3 crossBT = glm::<span class="built_in">cross</span>(rB, tangent);</span><br><span class="line"></span><br><span class="line">        glm::vec3 invInertiaCrossAT = invInertiaA * crossAT;</span><br><span class="line">        glm::vec3 invInertiaCrossBT = invInertiaB * crossBT;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> termAT = invMassA + glm::<span class="built_in">dot</span>(crossAT, invInertiaCrossAT);</span><br><span class="line">        <span class="type">float</span> termBT = invMassB + glm::<span class="built_in">dot</span>(crossBT, invInertiaCrossBT);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> denominatorT = termAT + termBT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (denominatorT != <span class="number">0.0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> jt = -tangentVel / denominatorT;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> friction = (<span class="built_in">fabs</span>(tangentVel) &lt; <span class="number">0.01f</span>) ? staticFriction : dynamicFriction;</span><br><span class="line">            <span class="type">float</span> maxFriction = friction * <span class="built_in">fabs</span>(j);</span><br><span class="line">            jt = glm::<span class="built_in">clamp</span>(jt, -maxFriction, maxFriction);</span><br><span class="line"></span><br><span class="line">            glm::vec3 tangentImpulse = jt * tangent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic)</span><br><span class="line">                a-&gt;rigidbody-&gt;velocity -= tangentImpulse * invMassA,</span><br><span class="line">                a-&gt;rigidbody-&gt;angularVelocity += invInertiaA * glm::<span class="built_in">cross</span>(rA, tangentImpulse);</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic)</span><br><span class="line">                b-&gt;rigidbody-&gt;velocity += tangentImpulse * invMassB,</span><br><span class="line">                b-&gt;rigidbody-&gt;angularVelocity += invInertiaB * glm::<span class="built_in">cross</span>(rB, -tangentImpulse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="位置修正"><a href="#位置修正" class="headerlink" title="位置修正"></a>位置修正</h4><p>最后的这步沿穿透方向推出物体的位置修正其实不是必选项，只是为了修正下冲量方法带来的持续穿插表现罢了。在做物理时可以单走冲量亦或这个PBD方法，但由于冲量法更加物理，所以引擎还是主用的冲量法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Physics::ApplyPositionCorrections</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; data : collisionData)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.info.depth &gt; <span class="number">1e-3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Collider* a = data.colliderA;</span><br><span class="line">            Collider* b = data.colliderB;</span><br><span class="line">            <span class="type">const</span> CollisionInfo&amp; info = data.info;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> invMassA = (a-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic) ? <span class="number">1.0f</span> / a-&gt;rigidbody-&gt;mass : <span class="number">0.0f</span>;</span><br><span class="line">            <span class="type">float</span> invMassB = (b-&gt;rigidbody-&gt;type == RigidbodyComponent::Dynamic) ? <span class="number">1.0f</span> / b-&gt;rigidbody-&gt;mass : <span class="number">0.0f</span>;</span><br><span class="line">            <span class="type">float</span> totalInvMass = invMassA + invMassB;</span><br><span class="line"></span><br><span class="line">            glm::vec3 correction = info.depth / totalInvMass * info.normal * positionCorrectionFactor;</span><br><span class="line"></span><br><span class="line">            a-&gt;transform-&gt;position -= correction * invMassA;</span><br><span class="line">            b-&gt;transform-&gt;position += correction * invMassB;</span><br><span class="line"></span><br><span class="line">            a-&gt;isDirty = <span class="literal">true</span>; b-&gt;isDirty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记-1"><a href="#后记-1" class="headerlink" title="后记"></a>后记</h3><p>至此引擎在点击Play后也能有一定表现，可喜可贺。但作为游戏&#x2F;物理引擎这还是远远不够的，至少还得试试多线程。目前在release版放了2k个碰撞对后，物理帧耗时330微秒，FPS降到400+，留待后续对比。</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>之前已经实现了基础的物理模拟流程，但其在面对大量碰撞对时表现仍不算令人满意，为此接下来就要尝试并行化。第一步当然是写个线程池，靠线程池来管理线程和任务，之后再用图染色来避免应用冲量和位置修正时的加锁。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>既然要上线程池，不如一步到位来个工作窃取平衡下负载。以下为线程池的大致结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Worker</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::deque&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;   <span class="comment">// 任务队列（双端，用于窃取）</span></span><br><span class="line">        std::mutex mutex;                           <span class="comment">// 保护队列的互斥锁</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Worker&gt;&gt; workers;   <span class="comment">// 所有工作线程的本地数据</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;                <span class="comment">// 工作线程</span></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop;                           <span class="comment">// 停止标志</span></span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; next_thread_index;            <span class="comment">// 用于轮询分配任务的索引</span></span><br><span class="line"></span><br><span class="line">    std::mutex cv_mutex;                              <span class="comment">// 与条件变量配合的互斥锁</span></span><br><span class="line">    std::condition_variable cv;                        <span class="comment">// 全局条件变量，用于通知有新任务</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分块同步"><a href="#分块同步" class="headerlink" title="分块同步"></a>分块同步</h3><p>将区间均匀分块，再创建任务，提交到线程池</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::ParallelFor</span><span class="params">(<span class="type">size_t</span> start, <span class="type">size_t</span> end, std::function&lt;<span class="type">void</span>(<span class="type">size_t</span>)&gt; func)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">size_t</span> total = end - start;</span><br><span class="line">    <span class="type">size_t</span> numThreads = workers.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> chunkSize = (total + numThreads - <span class="number">1</span>) / numThreads; <span class="comment">// 简单分块</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">size_t</span>&gt; <span class="title">remaining</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    std::mutex local_mutex;</span><br><span class="line">    std::condition_variable local_cv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> t = <span class="number">0</span>; t &lt; numThreads; ++t) &#123;</span><br><span class="line">        <span class="type">size_t</span> blockStart = start + t * chunkSize;</span><br><span class="line">        <span class="type">size_t</span> blockEnd = std::<span class="built_in">min</span>(blockStart + chunkSize, end);</span><br><span class="line">        <span class="keyword">if</span> (blockStart &gt;= blockEnd) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        remaining++;</span><br><span class="line">        <span class="built_in">Enqueue</span>([<span class="keyword">this</span>, blockStart, blockEnd, &amp;func, &amp;remaining, &amp;local_cv, &amp;local_mutex]() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = blockStart; i &lt; blockEnd; ++i) &#123;</span><br><span class="line">                <span class="built_in">func</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(local_mutex);</span><br><span class="line">            <span class="keyword">if</span> (--remaining == <span class="number">0</span>) &#123;</span><br><span class="line">                local_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有块完成</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(local_mutex)</span></span>;</span><br><span class="line">    local_cv.<span class="built_in">wait</span>(lock, [&amp;remaining] &#123; <span class="keyword">return</span> remaining == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p>当有任务加入时，线程池会先轮询再尾插。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::Enqueue</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 轮询选择一个目标线程的本地队列</span></span><br><span class="line">    <span class="type">size_t</span> target = next_thread_index.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed) % workers.<span class="built_in">size</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(workers[target]-&gt;mutex)</span></span>;</span><br><span class="line">        workers[target]-&gt;tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工作循环"><a href="#工作循环" class="headerlink" title="工作循环"></a>工作循环</h3><p>而在主循环中会优先从本地队列头部取任务，若本地队列为空，尝试从尾部窃取窃取其他线程的任务，之后执行任务或进行等待。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::WorkerLoop</span><span class="params">(<span class="type">size_t</span> myIndex)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Worker&amp; myWorker = *workers[myIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop) </span><br><span class="line">    &#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(myWorker.mutex, std::try_to_lock)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>() &amp;&amp; !myWorker.tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                task = std::<span class="built_in">move</span>(myWorker.tasks.<span class="built_in">front</span>());</span><br><span class="line">                myWorker.tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!task) &#123;</span><br><span class="line">            <span class="type">size_t</span> numWorkers = workers.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> offset = <span class="number">1</span>; offset &lt; numWorkers; ++offset) &#123;</span><br><span class="line">                <span class="type">size_t</span> victimIdx = (myIndex + offset) % numWorkers;</span><br><span class="line">                Worker&amp; victim = *workers[victimIdx];</span><br><span class="line">                <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(victim.mutex, std::try_to_lock)</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>() &amp;&amp; !victim.tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    task = std::<span class="built_in">move</span>(victim.tasks.<span class="built_in">back</span>()); <span class="comment">// 从尾部窃取</span></span><br><span class="line">                    victim.tasks.<span class="built_in">pop_back</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task)  <span class="built_in">task</span>();</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(cv_mutex);</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || <span class="built_in">has_any_task</span>(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并行模拟"><a href="#并行模拟" class="headerlink" title="并行模拟"></a>并行模拟</h3><h4 id="合并数据"><a href="#合并数据" class="headerlink" title="合并数据"></a>合并数据</h4><p>之后所有的步骤都可以靠线程池的分块同步来改写。但需要注意的是在宽向检测和窄向检测时最后的结果都写了数组的，而如果走并行的话合并可以通过局部处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelPhysics::HandleNarrowCollisions</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    collisionData.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">size_t</span> numPairs = colliderPairs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (numPairs == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> numThreads = threadPool.<span class="built_in">thread_count</span>();</span><br><span class="line">    <span class="type">size_t</span> chunkSize = (numPairs + numThreads - <span class="number">1</span>) / numThreads;</span><br><span class="line">    <span class="type">size_t</span> numBlocks = (numPairs + chunkSize - <span class="number">1</span>) / chunkSize;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;CollisionData&gt;&gt; <span class="built_in">localData</span>(numBlocks);</span><br><span class="line"></span><br><span class="line">    threadPool.<span class="built_in">parallel_for</span>(<span class="number">0</span>, numBlocks, [&amp;](<span class="type">size_t</span> blockIdx) &#123;</span><br><span class="line">        <span class="type">size_t</span> start = blockIdx * chunkSize;</span><br><span class="line">        <span class="type">size_t</span> end = std::<span class="built_in">min</span>(start + chunkSize, numPairs);</span><br><span class="line">        <span class="keyword">auto</span>&amp; local = localData[blockIdx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = start; i &lt; end; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; pair = colliderPairs[i];</span><br><span class="line">            CollisionInfo info = <span class="built_in">GJK_CheckCollision</span>(pair.first, pair.second);</span><br><span class="line">            <span class="keyword">if</span> (info.flag &amp;&amp; info.depth &gt; <span class="number">1e-3</span>f) &#123;</span><br><span class="line">                local.<span class="built_in">emplace_back</span>(pair.first, pair.second, info);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; local : localData) &#123;</span><br><span class="line">        collisionData.<span class="built_in">insert</span>(collisionData.<span class="built_in">end</span>(), local.<span class="built_in">begin</span>(), local.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="图染色分组"><a href="#图染色分组" class="headerlink" title="图染色分组"></a>图染色分组</h4><p>以及在冲量处理和位置修正时为了无锁用的图染色分组。大致为将碰撞对视为图中的边，刚体视为图中的顶点。需要为每条边分配一种颜色（组号），使得相邻的边不能有相同颜色。引擎中采用一种近似贪婪算法，快速生成可并行的组。使得每个组内的碰撞对不共享任何刚体，从而可以在组内安全地并行求解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelPhysics::BuildCollisionGroups</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    collisionGroups.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (collisionData.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(collisionData.<span class="built_in">begin</span>(), collisionData.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">const</span> CollisionData&amp; a, <span class="type">const</span> CollisionData&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.info.depth &gt; b.info.depth;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; bodyMask;</span><br><span class="line">    <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; bodyEpoch;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> globalEpoch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> maxId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; data : collisionData) &#123;</span><br><span class="line">        maxId = std::<span class="built_in">max</span>(maxId, (<span class="type">size_t</span>)data.colliderA-&gt;id);</span><br><span class="line">        maxId = std::<span class="built_in">max</span>(maxId, (<span class="type">size_t</span>)data.colliderB-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bodyMask.<span class="built_in">size</span>() &lt;= maxId) &#123;</span><br><span class="line">        bodyMask.<span class="built_in">resize</span>(maxId + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        bodyEpoch.<span class="built_in">resize</span>(maxId + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++globalEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; data : collisionData) &#123;</span><br><span class="line">        <span class="type">int</span> aId = data.colliderA-&gt;id;</span><br><span class="line">        <span class="type">int</span> bId = data.colliderB-&gt;id;</span><br><span class="line">        <span class="type">int</span> groupIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (groupIdx &gt;= (<span class="type">int</span>)collisionGroups.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                collisionGroups.<span class="built_in">emplace_back</span>();</span><br><span class="line">                collisionGroups.<span class="built_in">back</span>().<span class="built_in">push_back</span>(&amp;data);</span><br><span class="line">                bodyMask[aId] = groupIdx + <span class="number">1</span>;</span><br><span class="line">                bodyEpoch[aId] = globalEpoch;</span><br><span class="line">                bodyMask[bId] = groupIdx + <span class="number">1</span>;</span><br><span class="line">                bodyEpoch[bId] = globalEpoch;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">bool</span> aOccupied = (bodyEpoch[aId] == globalEpoch &amp;&amp; bodyMask[aId] == groupIdx + <span class="number">1</span>);</span><br><span class="line">            <span class="type">bool</span> bOccupied = (bodyEpoch[bId] == globalEpoch &amp;&amp; bodyMask[bId] == groupIdx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!aOccupied &amp;&amp; !bOccupied) &#123;</span><br><span class="line">                collisionGroups[groupIdx].<span class="built_in">push_back</span>(&amp;data);</span><br><span class="line">                bodyMask[aId] = groupIdx + <span class="number">1</span>;</span><br><span class="line">                bodyEpoch[aId] = globalEpoch;</span><br><span class="line">                bodyMask[bId] = groupIdx + <span class="number">1</span>;</span><br><span class="line">                bodyEpoch[bId] = globalEpoch;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++groupIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记-2"><a href="#后记-2" class="headerlink" title="后记"></a>后记</h3><p>这么整上后release版的2k个碰撞对，物理帧耗时90微秒，FPS 1500+，对比串行的330微秒，FPS 400+算是成果显著。当然也不得不吐槽多线程实在太难整了，最开始没想自己写，依次尝试了OpenMP，TaskFlow，PPL，表现都和串行的相当，最后还得是自己搓多线程。以及在有了当前版本后又尝试了C20屏障，以为能再进一步，但表现又和串行相当。累了，就先这样吧。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ayinzhang.github.io">翼轸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ayinzhang.github.io/2026/02/18/2026-2-18-Build%20your%20own%20engine/">https://ayinzhang.github.io/2026/02/18/2026-2-18-Build%20your%20own%20engine/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ayinzhang.github.io" target="_blank">Ayin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%95%E6%93%8E%E5%B7%A5%E5%85%B7/">引擎工具</a></div><div class="post_share"><div class="social-share" data-image="https://picx.zhimg.com/v2-cd705e99c30a580cfc272964bedbb66c_1440w.png?source=ccfced1a" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2026/01/17/2026-1-17-Godot%20Jolt%20Parallel%20Comparison/" title="Godot Jolt并行对比"><img class="cover" src="https://picx.zhimg.com/v2-d28e53e000188ec10622ace95af2cfcb_1440w.png?source=ccfced1a" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Godot Jolt并行对比</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/19/2023-12-19-Summary%20of%20Unity%20Engine%20Tool%20Internship/" title="Unity引擎工具实习总结"><img class="cover" src="https://picx.zhimg.com/70/v2-cb56904f62d22673473a9344025ec21a_1440w.avis?source=172ae18b&biz_tag=Post" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-19</div><div class="title">Unity引擎工具实习总结</div></div></a></div><div><a href="/2024/12/22/2024-12-22-XNode%20Simple%20Visual%20Dialogue%20Editor/" title="XNode简介及可视化对话系统"><img class="cover" src="https://picx.zhimg.com/70/v2-b44e6f5c815f8fcfcc426f0b114edbbd_1440w.avis?source=172ae18b&biz_tag=Post" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-22</div><div class="title">XNode简介及可视化对话系统</div></div></a></div><div><a href="/2024/09/08/2024-9-8-Unity%20Meta%20Game%20Doxing%20Pre-research/" title="C# Meta游戏开盒预研"><img class="cover" src="https://pic1.zhimg.com/70/v2-79195a1f0b4d19e6bd553cdb1aeb5c6f_1440w.avis?source=172ae18b&biz_tag=Post" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-08</div><div class="title">C# Meta游戏开盒预研</div></div></a></div><div><a href="/2025/08/16/2025-8-16-Simply%20Exploration%20of%20Unity%20YooAsset%20+%20HybridCLR%20Hot%20Update/" title="Unity YooAsset + HybridCLR热更初探"><img class="cover" src="https://pic1.zhimg.com/v2-09bfa8f60abc5361104c7584f6df43cd_720w.jpeg?source=d16d100b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-16</div><div class="title">Unity YooAsset + HybridCLR热更初探</div></div></a></div><div><a href="/2026/01/15/2026-1-15-Analysis%20of%20Godot%20Physics%20Source%20Code/" title="Godot 物理源码分析"><img class="cover" src="https://picx.zhimg.com/v2-a58a4e744580865dce7d671dfb7ebbb3_1440w.png?source=ccfced1a" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-15</div><div class="title">Godot 物理源码分析</div></div></a></div><div><a href="/2026/01/17/2026-1-17-Godot%20Jolt%20Parallel%20Comparison/" title="Godot Jolt并行对比"><img class="cover" src="https://picx.zhimg.com/v2-d28e53e000188ec10622ace95af2cfcb_1440w.png?source=ccfced1a" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-17</div><div class="title">Godot Jolt并行对比</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">翼轸</div><div class="author-info__description">終末一般論</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ayinzhang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ayinzhang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1242857339@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不过是些许风霜罢了</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">1.2.</span> <span class="toc-text">准备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2"><span class="toc-number">2.</span> <span class="toc-text">界面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-1"><span class="toc-number">2.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87-1"><span class="toc-number">2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">绘制工具栏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%8A%9F%E8%83%BD%E7%95%8C%E9%9D%A2"><span class="toc-number">2.3.2.</span> <span class="toc-text">绘制功能界面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">2.4.</span> <span class="toc-text">后记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-number">3.</span> <span class="toc-text">模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-2"><span class="toc-number">3.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87-2"><span class="toc-number">3.2.</span> <span class="toc-text">准备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E8%BD%B4%E7%AE%97%E6%B3%95%EF%BC%88SAT%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">分离轴算法（SAT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GJK-EPA"><span class="toc-number">3.2.2.</span> <span class="toc-text">GJK-EPA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%AD%A5%E8%BF%9B"><span class="toc-number">3.3.</span> <span class="toc-text">物理步进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">主流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0bvh%E6%A0%91"><span class="toc-number">3.3.2.</span> <span class="toc-text">更新bvh树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%BD%E5%90%91%E6%A3%80%E6%B5%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">宽向检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%84%E5%90%91%E6%A3%80%E6%B5%8B"><span class="toc-number">3.3.4.</span> <span class="toc-text">窄向检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B2%E9%87%8F%E6%B1%82%E8%A7%A3"><span class="toc-number">3.3.5.</span> <span class="toc-text">冲量求解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E4%BF%AE%E6%AD%A3"><span class="toc-number">3.3.6.</span> <span class="toc-text">位置修正</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0-1"><span class="toc-number">3.4.</span> <span class="toc-text">后记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-number">4.</span> <span class="toc-text">并行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-3"><span class="toc-number">4.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.2.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E5%90%8C%E6%AD%A5"><span class="toc-number">4.3.</span> <span class="toc-text">分块同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">4.4.</span> <span class="toc-text">任务提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.5.</span> <span class="toc-text">工作循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%A8%A1%E6%8B%9F"><span class="toc-number">4.6.</span> <span class="toc-text">并行模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">4.6.1.</span> <span class="toc-text">合并数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E6%9F%93%E8%89%B2%E5%88%86%E7%BB%84"><span class="toc-number">4.6.2.</span> <span class="toc-text">图染色分组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0-2"><span class="toc-number">4.7.</span> <span class="toc-text">后记</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/02/18/2026-2-18-Build%20your%20own%20engine/" title="制作自己的引擎"><img src="https://picx.zhimg.com/v2-cd705e99c30a580cfc272964bedbb66c_1440w.png?source=ccfced1a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="制作自己的引擎"/></a><div class="content"><a class="title" href="/2026/02/18/2026-2-18-Build%20your%20own%20engine/" title="制作自己的引擎">制作自己的引擎</a><time datetime="2026-02-17T16:00:00.000Z" title="发表于 2026-02-18 00:00:00">2026-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/17/2026-1-17-Godot%20Jolt%20Parallel%20Comparison/" title="Godot Jolt并行对比"><img src="https://picx.zhimg.com/v2-d28e53e000188ec10622ace95af2cfcb_1440w.png?source=ccfced1a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Godot Jolt并行对比"/></a><div class="content"><a class="title" href="/2026/01/17/2026-1-17-Godot%20Jolt%20Parallel%20Comparison/" title="Godot Jolt并行对比">Godot Jolt并行对比</a><time datetime="2026-01-16T16:00:00.000Z" title="发表于 2026-01-17 00:00:00">2026-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/15/2026-1-15-Analysis%20of%20Godot%20Physics%20Source%20Code/" title="Godot 物理源码分析"><img src="https://picx.zhimg.com/v2-a58a4e744580865dce7d671dfb7ebbb3_1440w.png?source=ccfced1a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Godot 物理源码分析"/></a><div class="content"><a class="title" href="/2026/01/15/2026-1-15-Analysis%20of%20Godot%20Physics%20Source%20Code/" title="Godot 物理源码分析">Godot 物理源码分析</a><time datetime="2026-01-14T16:00:00.000Z" title="发表于 2026-01-15 00:00:00">2026-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/07/2026-1-7-Simply%20Exploration%20of%20Unity%20ML-Agents%20Reinforcement%20Learning/" title="Unity ML-Agents强化学习初探"><img src="https://picx.zhimg.com/v2-42d063eae19380631578c7a1af6acddd_1440w.png?source=ccfced1a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity ML-Agents强化学习初探"/></a><div class="content"><a class="title" href="/2026/01/07/2026-1-7-Simply%20Exploration%20of%20Unity%20ML-Agents%20Reinforcement%20Learning/" title="Unity ML-Agents强化学习初探">Unity ML-Agents强化学习初探</a><time datetime="2026-01-06T16:00:00.000Z" title="发表于 2026-01-07 00:00:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/19/2025-12-19-Simply%20Exploration%20of%20LLM%20PEFT%20Fine-tuning%20and%20Ollama%20Operation/" title="LLM PEFT微调 + Ollama运行初探"><img src="https://pic1.zhimg.com/v2-71b0fc16e8b2f0e3771e38494b646666_r.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LLM PEFT微调 + Ollama运行初探"/></a><div class="content"><a class="title" href="/2025/12/19/2025-12-19-Simply%20Exploration%20of%20LLM%20PEFT%20Fine-tuning%20and%20Ollama%20Operation/" title="LLM PEFT微调 + Ollama运行初探">LLM PEFT微调 + Ollama运行初探</a><time datetime="2025-12-18T16:00:00.000Z" title="发表于 2025-12-19 00:00:00">2025-12-19</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(1,1,1,0)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By 翼轸</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="translateLink" type="button" title="中英转换">ZH</button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'ayinzhang/ayinzhang.github.io',
      'data-repo-id': 'R_kgDOKl3Dog',
      'data-category-id': 'DIC_kwDOKl3Dos4CaqXe',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script data-pjax src="/self/btf.js"></script><script data-pjax src="/self/tw_en.js"></script><div class="aplayer no-destroy" data-id="8985244058" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script id="canvas_nest" defer="defer" color="0,0,0" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="且行且看,尽力而为,不要害怕,不要后悔" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/elica.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"right","hOffset":20,"vOffset":-130},"mobile":{"show":false,"scale":0.3},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>